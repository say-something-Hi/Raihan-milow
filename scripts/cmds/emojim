const axios = require("axios");

// Gemini API Configuration - Replace with your valid API key
const GEMINI_API_KEY = "YOUR_VALID_API_KEY_HERE";
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";

module.exports.config = {
  name: "emojim",
  version: "2.1",
  role: 0,
  author: "Assistant",
  description: "Get emoji meanings with Gemini AI",
  usePrefix: true,
  guide: "{pn} <emoji>",
  category: "ai",
  aliases: ["emoji", "emmeaning", "emojimeaning"]
};

// Cache to avoid duplicate API calls and reduce rate limiting issues
const emojiCache = new Map();
const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes cache

// Local emoji database as fallback
const localEmojiDatabase = {
  "üòä": "Smiling Face with Smiling Eyes - Expresses happiness, warmth, friendliness",
  "‚ù§Ô∏è": "Red Heart - Represents love, affection, strong positive feelings",
  "üòÇ": "Face with Tears of Joy - Represents intense laughter or amusement",
  "ü§î": "Thinking Face - Indicates thinking, pondering, or considering",
  "üî•": "Fire - Means something is excellent, exciting, or trending",
  "üéâ": "Party Popper - Celebrates joyous occasions and successes",
  "üëç": "Thumbs Up - Signifies approval, agreement, or that things are good",
  "üôè": "Folded Hands - Can mean please, thank you, prayer, or a high five",
  "üòç": "Smiling Face with Heart-Eyes - Expresses loving admiration or being in love",
  "üòé": "Smiling Face with Sunglasses - Shows coolness, confidence, or relaxation"
};

module.exports.onStart = async function ({ api, args, event }) {
  const emoji = args[0];
  const send = (msg) => api.sendMessage(msg, event.threadID, event.messageID);

  if (!emoji) {
    return send("‚ö†Ô∏è Please provide an emoji. Example: !emojimean üòä");
  }

  // Check cache first to reduce API calls
  const cachedResponse = emojiCache.get(emoji);
  if (cachedResponse && (Date.now() - cachedResponse.timestamp) < CACHE_DURATION) {
    return send(cachedResponse.data);
  }

  try {
    // Try Gemini API first
    const geminiResponse = await callGeminiAPI(emoji);
    
    if (geminiResponse.success) {
      const formattedResponse = `üéØ ${emoji} Meaning (via Gemini AI):\n\n${geminiResponse.meaning}\n\nüí° Source: Google Gemini AI`;
      
      // Cache the successful response
      emojiCache.set(emoji, {
        data: formattedResponse,
        timestamp: Date.now()
      });
      
      return send(formattedResponse);
    }
    
    // If Gemini fails, try Emojipedia as fallback
    const emojipediaResponse = await callEmojipedia(emoji);
    if (emojipediaResponse.success) {
      return send(`üìñ ${emoji} Meaning (via Emojipedia):\n\n${emojipediaResponse.meaning}\n\nüîó Source: Emojipedia.org`);
    }
    
    // If both APIs fail, use local database
    if (localEmojiDatabase[emoji]) {
      return send(`üìù ${emoji} Meaning (Local Database):\n\n${localEmojiDatabase[emoji]}\n\n‚ÑπÔ∏è Using cached data as APIs are unavailable`);
    }
    
    // Final fallback
    return send(`‚ùå Could not find meaning for "${emoji}". Try a different emoji or check back later.`);
    
  } catch (error) {
    console.error("Emoji meaning error:", error);
    return send("‚ùå Error retrieving emoji information. Please try again later.");
  }
};

// Gemini API call function with retry logic
async function callGeminiAPI(emoji, retries = 2) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      // Add delay between retries (exponential backoff)
      if (attempt > 0) {
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
      }
      
      const prompt = `Explain the emoji "${emoji}" in a concise way (max 150 characters). Include:
      1. Official name
      2. Primary meaning
      3. Common usage contexts`;

      const response = await axios.post(
        `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
        {
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 150,
            topP: 0.8,
            topK: 40
          }
        },
        {
          headers: {
            "Content-Type": "application/json",
          },
          timeout: 10000
        }
      );

      if (!response.data || !response.data.candidates || !response.data.candidates[0]) {
        throw new Error("Invalid API response structure");
      }

      const meaning = response.data.candidates[0].content.parts[0].text;
      return { success: true, meaning };
      
    } catch (error) {
      console.error(`Gemini API attempt ${attempt + 1} failed:`, error.message);
      
      // Don't retry on authentication errors
      if (error.response?.status === 403 || error.response?.status === 401) {
        return { 
          success: false, 
          error: "API authentication failed. Check your API key." 
        };
      }
      
      // Last attempt failed
      if (attempt === retries) {
        return { 
          success: false, 
          error: error.message 
        };
      }
    }
  }
}

// Emojipedia fallback function
async function callEmojipedia(emoji) {
  try {
    const encodedEmoji = encodeURIComponent(emoji);
    const response = await axios.get(`https://emojipedia.org/${encodedEmoji}/`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      },
      timeout: 8000
    });

    // Simple HTML parsing for Emojipedia
    const html = response.data;
    
    // Extract title
    const titleMatch = html.match(/<h1[^>]*>(.*?)<\/h1>/);
    const title = titleMatch ? 
      titleMatch[1].replace(/<[^>]*>/g, '').trim() : 
      `Emoji: ${emoji}`;
    
    // Extract description
    const descriptionMatch = html.match(/<section class="description"[^>]*>.*?<p>(.*?)<\/p>/s);
    let description = descriptionMatch ? 
      descriptionMatch[1].replace(/<[^>]*>/g, '').trim() : 
      "No detailed description available.";
    
    // Shorten if too long
    if (description.length > 200) {
      description = description.substring(0, 200) + '...';
    }
    
    return {
      success: true,
      meaning: `${title}\n\n${description}`
    };
    
  } catch (error) {
    console.error("Emojipedia fallback error:", error.message);
    return { success: false, error: error.message };
  }
}

// Optional: Add reply functionality for extended information
module.exports.onReply = async function ({ api, event, Reply }) {
  // You can extend this to handle follow-up questions about emojis
  api.sendMessage("‚ÑπÔ∏è Use the command again with a different emoji to get more meanings!", event.threadID, event.messageID);
};
